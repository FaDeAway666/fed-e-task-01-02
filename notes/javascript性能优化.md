# 背景知识

## 内存管理

内存：

从计算机层面来说，内存存放的是程序与数据，是一个线性排列的存储区域，CPU通过总线与内存进行数据交换。

从编程语言层面，内存指的是一片可操作的空间，由可读写单元组成

内存的管理，是指人为地去操作一片空间的申请、使用和释放

```js
// 内存申请
let obj = {}
// 内存使用
obj.name = 'pb'
// 内存释放
obj = null
```

## 垃圾回收与GC算法

什么是JS中的垃圾：

- 对象不再被引用时
- 对象不能从根上访问到时

JS的内存管理是自动的，JS引擎会将垃圾（不可达对象）占据的空间进行回收，这个过程称为垃圾回收

JS中的可达对象：

- 可以访问到的对象就是可达对象（通过引用、作用域链访问）
- 可达的标准就是从根出发是否能够被找到
- JS中的根可以理解为是全局变量对象

GC就是垃圾回收机制的简写，GC算法工作的时候，可以找到内存中的垃圾，并释放、回收空间。

GC算法就是查找垃圾，释放空间，回收空间的规则

常用的GC算法：

- 引用计数
- 标记清除
- 标记整理
- 分代回收（V8）

**引用计数**

设置引用数，判断当前引用数是否为0

维护一个引用计数器，当引用关系发生改变时修改引用数字，引用数字为0时立即回收

```js
function fn() {
	num = 1
}
fn() //由于num被全局变量所引用，因此执行了fn之后，num也不会被回收

function fn2() {
    let num = 2
}
fn()
// 由于num只能在fn中起作用，在fn执行之后引用变为0，会被当做垃圾进行回收
```

引用计数优点：

- 发现垃圾时立即回收
- 最大限度减少程序暂停

缺点：

- 无法回收循环引用的对象
- 时间开销大（需要监控引用数值）

**标记清除**

分为标记和清除两个阶段。第一步遍历所有对象，标记活动着的对象；第二步继续遍历所有对象，清除没有标记的对象，最后回收相应的空间

**判断对象是否活动的依据，是对象是否可达**

标记清除优点：

可以解决循环引用的问题

缺点：

会导致空间碎片化：由于当前回收的垃圾对象地址不连续，如果新分配的对象所占空间超过或小于之前回收的对象占据的内存空间，则不能让空间得到较好的利用

不能立即回收垃圾对象

**标记整理**

标记整理可看做标记清除的增强。标记阶段和标记清除一致，在回收阶段，会对空间进行整理，移动对象的位置，让活动对象在地址上产生连续

这样解决了空间碎片化的问题

## V8垃圾回收

V8是一款主流的JS执行引擎，采用即时编译的方式，执行速度快；V8的内存设置了上限，为了配合浏览器和GC机制

V8使用分代回收的策略，将内存空间分为新生代和老生代，分别按照一定的GC算法进行垃圾回收

V8中常用的GC算法

- 分代回收
- 空间复制
- 标记清除、标记整理
- 标记增量

**分代回收**

V8将内存空间分成两份，小空间用于新生代对象（64位系统有32M，32位系统有16M），新生代对象指的是**存活时间较短**（局部作用域内的对象）的对象。

新生代回收

- 回收过程采用复制算法+标记清理
- 新生代内存区分为两个等大空间，From和To
- 使用空间为From，空闲空间为To
- 活动对象存储From空间
- 标记整理后将活动对象拷贝至To
- 结束后将From与To进行交换

新生代回收的细节

- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动到老生代
- 一轮GC后依然存活的新生代需要晋升
- To空间的使用率超过25%（如果To的使用率超过一定限制，下次交换时可能存不进去）

老生代回收主要采用标记清除、标记整理、增量标记的算法，首先使用标记清除进行垃圾空间的回收，途中会采用标记整理进行空间优化，也会采用增量标记进行效率优化

老生代的存储空间设有上线，64位系统下是1.4G，32位系统下是700M

对比：

- 新生代垃圾回收采用了赋值算法，使用空间换取时间
- 老生代垃圾回收不适合复制算法，会造成空间浪费

增量标记

![image-20201210112116859](.\images\标记增量.png)

将长时间标记的停顿时间拆分成多个小段，程序执行与垃圾回收交替进行

# 内存监控

内存问题的体现

- 页面性能随着时间越来越差
- 持续卡顿
- 页面出现延迟加载或者经常性暂停

界定内存问题的标准：

- 内存泄露：内存使用持续升高
- 内存膨胀：在多数设备上都存在性能问题
- 频繁垃圾回收：通过内存变化图进行分析

监控内存的几种方式：

- 浏览器任务管理器
- timeline时序图
- 堆快照，查找分离DOM
- 判断是否存在频繁的垃圾回收

## Performance工具

可以通过这个工具来监控内存空间变化

使用步骤：

- 打开浏览器输入目标网址
- 进入开发人员工具面板，选择performance
- 开始录制，访问具体界面
- 执行用户行为，一段时间后停止录制
- 分析界面记录的内存信息

## 浏览器任务管理器

内存和js内存的区别：内存是DOM内存，JS内存是JS堆，所有可达对象所使用的内存大小

可以通过观测JS内存的增长，判断js内存是否有问题

## 堆快照

分离DOM：节点从DOM树上脱离，但有JS对象引用了这个节点

垃圾DOM：如果节点从DOM树上脱离，也没有js对象引用节点

通过memory-->heap snapshot拍摄堆快照，搜索detached ，查找分离DOM，即可发现分离的DOM

## 判断是否存在频繁GC

频繁GC造成的问题：

- GC工作时应用程序是停止的
- 频繁且过长的GC会导致应用假死
- 用户使用的时候感知卡顿

判断方法：

- TimeLine中内存时序频繁的上升下降
- 任务管理器中数据频繁地增加减小

## JS代码优化

可以使用JSBench工具来观察代码优化前后的性能对比，网址https://jsbench.me/

### 慎用全局变量

- 全局变量定义在全局执行上下文，是所有作用域链的顶端
- 全局执行上下文一直存在于上下文执行栈，直到程序退出
- 如果某个局部作用域出现了同名变量则会污染全局

在实现相同的功能时，使用全局变量的效率不如使用局部变量

### 缓存全局变量

将使用中无法避免的全局变量缓存到局部，对性能会有少量的提升

```js
function getBtn() {
	let btn1 = document.getElementById('btn1')
	let btn3 = document.getElementById('btn3')
	let btn5 = document.getElementById('btn5')
	let btn7 = document.getElementById('btn7')
	let btn9 = document.getElementById('btn9')
}

function getBtn() { 
	let d = document // 用局部变量缓存全局对象
	let btn1 = d.getElementById('btn1')
	let btn3 = d.getElementById('btn3')
	let btn5 = d.getElementById('btn5')
	let btn7 = d.getElementById('btn7')
	let btn9 = d.getElementById('btn9')
}
```

### 在原型上新增实例对象需要的方法

在原型上新增方法，比在构造函数中新增方法，性能要稍好一些

原因是在创建多个实例的时候，使用构造函数创建方法，每个实例都会在内存空间中存在这个方法，而使用原型创建方法，实例调用方法时会从原型上查找，而内存空间中没有，这样就节省了内存空间

```js
var fn = function() {
	this.foo = function() {
        console.log('pbpb')
    }
}

var fn2 = function() {}
fn2.prototype.foo = function() {
    console.log('pbpb')
}
```

### 闭包陷阱

- 闭包容易造成内存泄漏
- 不要为了闭包而闭包

尽量减少闭包的使用，如果使用了闭包，要在不使用的时候，进行内存释放

### 循环优化

for循环在指定循环条件的时候，如果有计算或者调用方法的地方，需要将这些条件取出来成为一个变量，不要每次循环的时候都去计算

```js
for(let i=0; i < calc(something); i++)

// 改进后
let res = calc(something)
for(let i=0; i < res; i++)
```

对于forEach for for...in之间的性能，forEach 的性能最好，如果只是单纯遍历，选择forEach最佳

### DOM节点添加优化

节点的添加操作会有回流和重绘，需要使用DocumentFragment添加后在一次性append到DOM中

```js
const fragment = document.createDocumentFragment()
for(let i=0; i < 10; i++) {
    let p = document.createElement(p)
    fragment.append(p)
}
document.append(fragment)
```

