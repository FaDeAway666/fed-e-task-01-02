# 简单题

#### 一、请说出下列最终的执行结果，并解释为什么。

```js
var a = []
for(var i = 0; i < 10; i++){
  a[i] = function() {
    console.log(i)
  }
 }
a[6]()
```

答案是10

经过循环之后，a中添加了10个function，每个function都会打印i，由于i由var关键字声明，处于全局作用域上，经过循环后的i的值为10，因此只会打印出10

#### 二、请说出下列最终的执行结果，并解释为什么。

```js
var tmp = 123
if(true) {
  console.log(tmp)
  let tmp
}
```

会报错，因为if语句形成了一个局部的块级作用域，这个作用域中先访问了tmp变量，再使用let对tmp进行声明，会产生暂时性死区，JS引擎会报错

#### 三、结合ES6新语法，用最简单的方式找出数组的最小值。

```js
var arr = [12, 34, 32, 89, 4]
```

```js
const res = arr.sort((a,b) => a - b)[0]
```

#### 四、请详细说明var，let，const三种声明变量的方式之间的具体差别。

**var与let/const的区别**

1. let和const是ES2015标准中提出用于声明变量的关键字，var是在ES2015之前用于声明变量的关键字
2. 使用var声明的变量，可以在进行变量声明之前就使用这个变量，而let和const声明变量则不能这样操作
3. var允许重复声明，而let和const不允许
4. ES2015之前没有块级作用域的概念，因此使用var会产生一些不合理的场景，例如内层变量覆盖了外层变量

**let和const的区别**

1. let不需要赋初始值，const需要
2. let声明的变量值或引用地址可以更改，const不行

#### 五、请说出下列代码最终输出的结果，并解释为什么。

```js
var a = 10
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```

答案是20

fn函数是obj对象的属性，当被obj调用的时候，this指向是obj对象，因此返回的是obj.a

#### 六、简述symbo1类型的用途。

在ES2015之前，对象的属性只能使用字符串，而字符串是有可能重复的

Symbol代表独一无二的值，使用Symbol作为属性名，可以避免对象属性名重复

也可以用Symbol来模拟对象的私有变量

```js
const name = Symbol()
const Person {
	[name]: 'pb',
	getName() {
		console.log(this[name])
	}
}

Person.name // undefined
Person.getName() // pb
```

#### 七、说说什么是浅拷贝，什么是深拷贝?

深浅拷贝都是对于引用类型的变量而言的概念

浅拷贝指复制了被拷贝对象的内存地址，如果被拷贝对象的内存地址发生改变，则会影响拷贝后的对象

深拷贝指在内存中开辟一个新的区域，存放被拷贝对象的全部内容，包括对其子对象进行递归拷贝。修改被拷贝对象，不会影响到拷贝后的对象

#### 八、请简述TypeScript 与 JavaScript之间的关系。

TypeScript是JavaScript的超集，为了解决JavaScript类型系统不足的问题，包括了类型系统，ES6+等扩展内容

TypeScript可以使用JavaScript的所有代码概念

#### 九、请谈谈你所认为的TypeScript 优缺点。

优点：

1. TS是一门强类型静态语言，可以在声明阶段就排除掉很多执行时可能的错误，使得代码更加健壮、易于维护
2. 对于ES6+的支持，有助于提高编码效率
3. 更适合开发大型项目

缺点：

1. 增加了学习成本
2. 与现存的一些库不能完美兼容

#### 十、描述引用计数的工作原理和优缺点。

引用计数是一种常用的GC算法，工作原理是在内存中维护一个引用计数器，对内存中的变量进行引用的计数，当引用关系发生改变时修改计数。当计数变为0时，立刻回收该对象

优点：

- 发现垃圾时可以立刻回收
- 因为一发现垃圾就立刻回收，可以最大程度上减少程序暂停

缺点：

- 维持引用计数器，会造成额外的时间开销
- 无法回收循环引用的对象

#### 十一、描述标记整理算法的工作流程。

标记整理算法是标记回收算法的增强，分为两个阶段：

标记阶段：遍历所有对象，标记处于活动状态的对象

整理阶段：再次遍历所有对象，将未被标记的对象进行回收，回收之后对内存空间进行整理，移动对象的位置，使得活动对象在地址上产生连续

#### 十二、描述V8中新生代存储区垃圾回收的流程。

新生代垃圾回收过程中采用复制算法+标记整理。

首先将内存区分为两个等大空间，From和To，先在From空间中分配对象，一轮执行过后，将依旧活动的对象复制到To空间中，清除掉From空间中所有非活动对象，再将From空间和To空间进行交换，以此进行循环

#### 十三、描述增量标记算法在何时使用及工作原理。

增量标记算法在V8老生代进行垃圾回收时进行使用

因为老生代内存较大，一次性遍历的GC会导致程序的停顿，因此增量标记的原理是先标记内存中的一部分对象，再执行一段时间代码，将长时间的标记停顿时间分为多个小段，使得程序执行与垃圾回收交替进行